/**
 * This class will calculate the number of moves 
 * it needs to take from the starting position to the
 * ending position of a TilePuzzle using merit cost.
 * 
 * @version 4/17/2012
 * @author Rob Avery <pw97976@umbc.edu>
 * CMSC 341 - Spring 2012 - Project 3
 * Section 02
 */

package proj3;

public class TilePuzzleSolver {
	
	//Stored beginning and ending Puzzle "pictures"
	private TilePuzzle beginning;
	private TilePuzzle ending;
	
	//First five Tiles from Puzzle
	TilePuzzle firstFive[];	
	
	//Stores all the children that are generated by the parents
	//Priority = merit cost of the TilePuzzle
	//merit cost = h + g
	BinaryHeap<TilePuzzle> openQ;
	
	/**
	 * Takes in two TilePuzzles to setup the start of 
	 * finding the solution to the end
	 * @param b - the beginning TilePuzzle
	 * @param e - the final ending TilePuzzle
	 */
	public TilePuzzleSolver ( TilePuzzle b, TilePuzzle e ) {	
		
		beginning = new TilePuzzle( b );
		ending = new TilePuzzle( e );
		firstFive = new TilePuzzle[5];
		
		beginning.setMerit( beginning.h( ending ), 0 );
	}
	
	/**
	 * Used to take the information saved in this class
	 * and solve the TilePuzzle using "best-first" method
	 */
	public void solve( ) {
		
		openQ = new BinaryHeap<TilePuzzle>( );
		TilePuzzle Sk = new TilePuzzle( beginning );
		TilePuzzle child;
		int g = 0;
		int first = 0;
		
		Sk.setMerit( Sk.h(ending) , g );
		openQ.insert( Sk );
		
		while( !openQ.isEmpty() ) {
			
			Sk = openQ.deleteMin();
			g = Sk.getG();
			
			
			if( first < 5)
				firstFive[first] = Sk;
				
			if( Sk.h( ending ) == 0 ) {
				Sk.setMerit( ending.h(ending) , g);
				break;
			}
			/*if( Sk.deadState() ){
				//Do nothing
				g--;
			}*/
			else {
				g++;
				
				//IF POSSIBLE
				//Moves Filled Tile up
				//Moves Empty Tile down
				child = new TilePuzzle( Sk );
				if( Sk.canMoveUp() ){
					
					child.moveUp();
					if( !child.isEqualToParent() ){
						child.setMerit( child.h( ending ), g );
						openQ.insert( child );
					}
				}
				
				
				//IF POSSIBLE
				//Moves Filled Tile down
				//Moves Empty Tile up
				child = new TilePuzzle( Sk );
				if( Sk.canMoveDown() ){
					
					child.moveDown();
					if( !child.isEqualToParent() ){
						child.setMerit( child.h( ending ), g );
						openQ.insert( child );
					}
				}
				
				
				//IF POSSIBLE
				//Moves Filled Tile left
				//Moves Empty Tile right
				child = new TilePuzzle( Sk );
				if( Sk.canMoveLeft() ){
					
					child.moveLeft();
					if( !child.isEqualToParent() ){
						child.setMerit( child.h( ending ), g );
						openQ.insert( child );
					}
				}
				
				
				//IF POSSIBLE
				//Moves Filled Tile right
				//Moves Empty Tile left
				child = new TilePuzzle( Sk );
				if( Sk.canMoveRight() ){
					
					child.moveRight();
					if( !child.isEqualToParent() ){
						child.setMerit( child.h( ending ), g );
						openQ.insert( child );
					}
				}
				
							
			}//else
			
			first++;
		}//while
		ending.setMerit( ending.h( ending ), g );
	}
	
	/**
	 * A hard coded print method that prints all the desired information in
	 * a neatly matter
	 */
	public void printResults(){
		
		System.out.println("Initial State (S0)");
		System.out.println("==================");
		System.out.println( beginning );
		System.out.println("Goal State (Sg)");
		System.out.println("=======================");
		System.out.println( ending );
		System.out.println("\n-----------------------------------");
		
		System.out.println("Solution cost is: " + ending.getMerit() );
		System.out.println("Size of openQ at the end of the search process: " + openQ.getSize() );
		System.out.println("-----------------------------------");
		
		System.out.println("\nFirst five states removed from openQ:");
		for( int i = 0; i < firstFive.length; i++ ){
			if( firstFive[i] != null ){
				System.out.println("State #" + (i+1) );
				System.out.println("--------");
				System.out.println( firstFive[i] + "\n");
			}
		}

	}
}
